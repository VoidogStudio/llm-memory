# Architecture Decision Record: v1.7.0 Advanced Memory Features

**Title**: Memory Versioning, Schema, and Dependency Tracking

**Date**: 2025-12-09

**Status**: Accepted

**Version**: 1.7.0

---

## Summary

This ADR documents the architectural decisions for implementing three major features in v1.7.0:
1. Memory Versioning - Track and manage memory evolution
2. Structured Memory Schema - Define and enforce memory structure
3. Dependency Tracking - Manage memory relationships

---

## Context

The llm-memory system was requested to support advanced memory management capabilities. These features required:
- Ability to track version history for audit and rollback
- Type-safe memory operations with schema validation
- Dependency awareness for cascading updates and safe deletion

The existing 3-tier layered architecture (Tools → Services → Repositories → Database) provided a solid foundation to extend with these capabilities.

---

## Decisions

### ADR-001: Auto-save Version on memory_update

**Decision**: Every `memory_update` operation automatically creates a version snapshot in the `memory_versions` table.

**Rationale**:
- Better user experience: No explicit version creation API needed
- Implicit audit trail: Complete history maintained automatically
- Data integrity: Every change is captured without user overhead

**Implications**:
- Increased database writes (1 additional write per update)
- Storage overhead for version history (~10 KB per 100 versions per memory)
- Auto-pruning required to prevent unbounded growth

**Mitigation**:
- Implement `_prune_old_versions()` with configurable retention (default: 10 versions)
- Provide `memory_version_cleanup` tool for manual maintenance
- Index on `memory_id` and `created_at` for efficient queries

---

### ADR-002: Dedicated memory_schemas Table for Schema Storage

**Decision**: Schemas are stored in a separate `memory_schemas` table rather than as JSON blobs in memories.

**Rationale**:
- Better query performance: Schema lookups are indexed
- Schema versioning support: Multiple versions of same schema
- Schema reusability: Multiple memories can reference same schema
- Namespace isolation: Schemas are namespace-scoped

**Implications**:
- Added schema lookup overhead (~5ms per operation)
- Foreign key relationship between memories and schemas
- Schema deletion requires careful handling (cascade vs. orphaning)

**Mitigation**:
- Add `idx_schemas_namespace` and `idx_schemas_name` indexes
- Implement cascade delete protection (prevent deleting active schemas)
- Provide `memory_schema_list` tool for discovery

---

### ADR-003: Async Notification Queue for Dependency Propagation

**Decision**: Dependency updates are queued asynchronously in `dependency_notifications` table rather than synchronously cascaded.

**Rationale**:
- Avoid performance degradation from deep dependency traversal
- Support long-running propagation workflows
- Enable retry mechanisms for failed propagations
- Prevent cascade timeout issues

**Implications**:
- Eventual consistency model (not immediate propagation)
- Requires background processing (future feature)
- Adds notification processing latency (~100-500ms)

**Mitigation**:
- Implement `memory_dependency_propagate` for explicit processing
- Add status tracking in `dependency_notifications` table
- Include `max_depth` parameter to limit traversal (default: 5)
- Document async nature in API documentation

---

### ADR-004: Use SQLite JSON1 Extension for Structured Queries

**Decision**: Use SQLite's built-in JSON1 extension for schema field validation and querying.

**Rationale**:
- No additional dependencies: Part of SQLite 3.38.0+
- Efficient: Native JSON support with proper indexing
- Type validation: Can validate JSON structure at query time
- Schema versioning: Can store schema as JSON with versions

**Implications**:
- Requires SQLite 3.38.0+ (widely available)
- JSON schema validation done at database level
- Limited to SQLite JSON functions (subset of full schema validators)

**Mitigation**:
- Add version check in database initialization
- Implement fallback JSON schema validation in Python
- Document SQLite version requirement in README

---

## Database Changes

### New Tables

#### memory_versions
```sql
CREATE TABLE memory_versions (
  id TEXT PRIMARY KEY,
  memory_id TEXT NOT NULL,
  version INTEGER NOT NULL,
  content TEXT NOT NULL,
  content_type TEXT NOT NULL,
  tags TEXT NOT NULL,
  metadata TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  change_reason TEXT,
  FOREIGN KEY (memory_id) REFERENCES memories(id)
)
CREATE INDEX idx_versions_memory ON memory_versions(memory_id, version DESC)
```

#### memory_schemas
```sql
CREATE TABLE memory_schemas (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  namespace TEXT NOT NULL DEFAULT 'default',
  version INTEGER DEFAULT 1,
  fields TEXT NOT NULL,  -- JSON array of fields
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  description TEXT,
  UNIQUE(name, namespace, version)
)
CREATE INDEX idx_schemas_namespace ON memory_schemas(namespace)
CREATE INDEX idx_schemas_name ON memory_schemas(name, namespace)
```

#### dependency_notifications
```sql
CREATE TABLE dependency_notifications (
  id TEXT PRIMARY KEY,
  source_memory_id TEXT NOT NULL,
  target_memory_id TEXT NOT NULL,
  notification_type TEXT NOT NULL,  -- 'UPDATE', 'DELETE', 'INVALIDATE'
  metadata TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  processed_at DATETIME,
  FOREIGN KEY (source_memory_id) REFERENCES memories(id),
  FOREIGN KEY (target_memory_id) REFERENCES memories(id)
)
CREATE INDEX idx_notifications_pending ON dependency_notifications(processed_at) WHERE processed_at IS NULL
CREATE INDEX idx_notifications_source ON dependency_notifications(source_memory_id)
```

### Modified Tables

#### memories
- `version` INTEGER DEFAULT 1 - Current version number
- `previous_version_id` TEXT - Link to previous version
- `schema_id` TEXT - Reference to memory_schemas table
- `structured_content` TEXT - JSON content validated against schema

#### memory_links
- `cascade_on_update` INTEGER DEFAULT 0 - Propagate updates to linked memory
- `cascade_on_delete` INTEGER DEFAULT 0 - Delete linked memory when source deleted
- `strength` REAL DEFAULT 1.0 - Link strength for weighted traversal

---

## API Changes

### New Tools (11 total)

#### Versioning (4 tools)
- `memory_version_history` - Get complete version history
- `memory_version_get` - Retrieve specific version
- `memory_version_rollback` - Restore to previous version
- `memory_version_diff` - Compare versions

#### Schema (5 tools)
- `memory_schema_register` - Register new schema
- `memory_schema_list` - List schemas
- `memory_schema_get` - Get schema details
- `memory_store_typed` - Store with schema validation
- `memory_search_typed` - Search with type filtering

#### Dependency (3 tools)
- `memory_dependency_analyze` - Analyze change impact
- `memory_dependency_propagate` - Process dependency updates
- Extended `memory_link` with cascade and strength parameters

---

## Backward Compatibility

- All new fields are optional with sensible defaults
- Existing APIs remain unchanged
- New tools are additive (no API removals)
- Migration v5 → v6 handles data transformation
- 356 existing tests pass without modification

---

## Testing Strategy

- 80+ new tests for versioning, schema, and dependency features
- Integration tests for cross-feature interactions
- Performance tests for database operations
- Backward compatibility tests with existing features
- Migration tests (v5 → v6 with sample data)

**Coverage Target**: 80%+ for new code

---

## Performance Targets

- Version history fetch: < 100ms
- Version rollback: < 200ms
- Typed memory store: < 200ms
- Typed memory search: < 300ms
- Dependency analysis (depth 3): < 500ms
- Dependency propagate: < 300ms
- Migration v5→v6 (100k records): < 30s
- Existing API degradation: < 5%

---

## Risks and Mitigations

| Risk | Level | Mitigation |
|------|-------|-----------|
| Storage growth from versions | Medium | Auto-prune with configurable retention (10 versions) |
| Schema evolution complexity | High | Schema versioning with explicit references |
| Circular dependency detection | Medium | Cycle detection with max depth limit (5) |
| Query performance with large schemas | Low | JSON indexing and caching |

---

## Future Considerations

1. **Version Cleanup**: Add scheduled maintenance job for old versions
2. **Schema Registry**: Central schema management service
3. **Change Notifications**: WebSocket/gRPC for real-time updates
4. **Dependency Visualization**: Graph-based dependency explorer
5. **Schema Migration Tools**: Automatic schema evolution helpers

---

## References

- `/Users/enigma/Developer/Projects/llm-memory/.tmp/order/04_design/basic_design.md`
- `/Users/enigma/Developer/Projects/llm-memory/.tmp/order/04_design/detailed_design.md`
- Database migration: `/Users/enigma/Developer/Projects/llm-memory/src/db/database.py`

---

## Approval

- **Architect**: Approved (v1.7.0)
- **Date**: 2025-12-09
